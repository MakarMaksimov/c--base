#include<string>
#include<iostream>

using namespace std;

int main()
{
    string s = "Hello world";
    s += 'a';
    cout << s << endl;
    s.pop_back(); // удалить из строки последний символ
    cout << s << endl;
    cout << s.back() << endl; // последний элемент строки
    // s = ""; // полностью очистить строку
    s.insert(5, "_my"); // вставляет строчку начиная с 5го
    cout << s << endl; // символа, все символы, стоявшие
    // в строке после 5, смещаются
    s.erase(5, 3); // удалить 3 символа начиная с 5го
    cout << s << endl;
    s.erase(5); // удалить все символы начиная с 5го
    // это работает за счёт того, что кол-во символов
    // для удаления имеет стандартное значение string::npos,
    // которое равно максимально возможному значению
    // длины строки. Из этого можно заметить, что если мы
    // передадим в качестве второго параметра длину, которая
    // выйдет за пределы строки, это не приведёт к ошибке
    cout << s << endl;
    s.erase(); // удалить все символы из строки (значение
    // по умолчанию для первого параметра = 0

    s = "Hello world";
    cout << s.substr(6, 3) << endl; // выделить подстроку
    // начиная с 6го символа длиной 3 символа
    cout << s.substr(6) << endl; // если не указывать
    // второй параметр или указать его слишком большим,
    // то возьмётся подстрока до конца строки
    cout << s.substr() << endl; // берёт подстроку с 0 символа
    // до конца строки (создаёт копию исходной строки)
    // первый параметр не должен выхходит за пределы строки
    cout << s.find("o") << endl; // номер первого вхождения
    // буквы "o"
    cout << s.find("o", 5) << endl; // первое вхождение буквы о,
    // начиная с 5го символа
    cout << s.find("o", 8) << endl; // если искомой подстроки нет,
    // то возвращается string::npos
    // if (s.find("o", 8) == -1) // npos при приведении его
    if (s.find("o", 8) == string::npos) // к знаковомму типу
        cout << "No more 'o'" << endl; // превращается в -1
    cout << int(string::npos);
    cout << endl;
    cout << s.rfind("o") << endl; // искать вхождение подстроки
    // справа налево (тоже можно использовать второй параметр)
    cout << s.rfind("o", 6) << endl; // тогда будет искать
    // начиная с 6го символа левее
    // iterator - умный указатель, которй позволяет пройти по
    // контейнеру не по номерам, а по адресам ячеек
    // s.begin() - указатель на первый элемент
    // s.end() - указатель на точку полсе последнего элемента
    // это сделано для того, чтобы можно было идти до it != s.end()
    // и обработать таким образом ВСЕ элементы (в том числе последний)
    for (string::iterator it = s.begin(); it != s.end(); it++)
        cout << *it << " ";
    cout << endl;
    // auto - автоматически определить тип данных на основе
    // присваемого значения
    for (auto it = s.begin(); it != s.end(); it++)
        cout << *it << " ";
    cout << endl;
    // reverse итераторы позволяют удобно "ходить"
    // справа налево (при этом указатель всеравно растёт: it++)
    for (auto it = s.rbegin(); it != s.rend(); it++)
        cout << *it << " ";
    cout << endl;
    // строки можно сравнивать
    string("abc") == string("abc"); //true
    string("abc") > string("abs"); // false, сравнение лексикографическое
    // т.е. как в словаре, слова сравниваются по первой несовпавшей букве
    // буквы сравниваются по порядку в алфавите (по ascii кодам)
    // ям < яма < ямб < яр
    // Ещё можно пройтись по строке, с помощью цикла foreach
    for (char c: s)
        cout << c << " ";
}
